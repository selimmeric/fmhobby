C51 COMPILER V9.00   HAL_UART                                                              10/26/2011 16:27:04 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE HAL_UART
OBJECT MODULE PLACED IN hal_uart.OBJ
COMPILER INVOKED BY: C:\KeilC51\C51\BIN\C51.EXE hal_uart.c OMF2 BROWSE DEBUG

line level    source

   1          /* Copyright (c) 2009 Nordic Semiconductor. All Rights Reserved.
   2           *
   3           * The information contained herein is confidential property of Nordic 
   4           * Semiconductor ASA.Terms and conditions of usage are described in detail 
   5           * in NORDIC SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
   6           *
   7           * Licensees are granted free, non-transferable use of the information. NO
   8           * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9           * the file.
  10           *              
  11           * $LastChangedRevision: 133 $
  12           */
  13          
  14          /** @file
  15           * @brief Implementation of hal_uart
  16           */
  17          
  18          //lint -e788
  19          //lint -e714
  20          
  21          //#include "nrf24le1.h"
  22          #include "reg24le1.h"
  23          #include <stdint.h>
  24          #include <stdbool.h>
  25          #include "hal_uart.h"
  26          
  27          #ifndef UART_NBUF
  28          #define UART_NBUF   8
  29          #endif
  30          
  31          #define BAUD_57K6   1015  // = Round(1024 - (2*16e6)/(64*57600))
  32          #define BAUD_38K4   1011  // = Round(1024 - (2*16e6)/(64*38400))
  33          #define BAUD_19K2    998  // = Round(1024 - (2*16e6)/(64*19200))
  34          #define BAUD_9K6     972  // = Round(1024 - (2*16e6)/(64*9600))
  35          
  36          static uint8_t uart_tx_wp, uart_tx_rp, uart_tx_cnt;
  37          static uint8_t idata uart_tx[UART_NBUF];
  38          
  39          static uint8_t uart_rx_wp, uart_rx_rp, uart_rx_cnt;
  40          static uint8_t idata uart_rx[UART_NBUF];
  41          
  42          UART0_ISR()
  43          {
  44   1        if (RI0 == 1)
  45   1        {
  46   2          RI0 = 0;
  47   2          if (uart_rx_cnt < UART_NBUF)
  48   2          {
  49   3            uart_rx[uart_rx_wp] = S0BUF;
  50   3            uart_rx_wp = (uart_rx_wp + 1) % UART_NBUF;
  51   3            uart_rx_cnt++;
  52   3          }
  53   2        }
  54   1        if (TI0 == 1)
  55   1        {
C51 COMPILER V9.00   HAL_UART                                                              10/26/2011 16:27:04 PAGE 2   

  56   2          TI0 = 0;
  57   2          if (uart_tx_cnt > 1)
  58   2          {
  59   3            S0BUF = uart_tx[uart_tx_rp];
  60   3            uart_tx_rp = (uart_tx_rp + 1) % UART_NBUF;
  61   3          }
  62   2          uart_tx_cnt--;
  63   2        }
  64   1      }
  65          
  66          void hal_uart_init(hal_uart_baudrate_t baud)
  67          {
  68   1        uint16_t temp;
  69   1      
  70   1        ES0 = 0;                      // Disable UART0 interrupt while initializing
  71   1        uart_tx_wp = uart_tx_rp = 0;
  72   1        uart_tx_cnt = 0;
  73   1        uart_rx_wp = uart_rx_rp = 0;
  74   1        uart_rx_cnt = 0;
  75   1        REN0 = 1;                     // Enable receiver
  76   1        SM0 = 0;                      // Mode 1..
  77   1        SM1 = 1;                      // ..8 bit variable baud rate
  78   1        PCON |= 0x80;                 // SMOD = 1
  79   1        ADCON |= 0x80;                // Select internal baud rate generator
  80   1        switch(baud)
  81   1        {
  82   2          case UART_BAUD_57K6:
  83   2            temp = BAUD_57K6;
  84   2            break;
  85   2          case UART_BAUD_38K4:
  86   2            temp = BAUD_38K4;
  87   2            break;
  88   2          case UART_BAUD_9K6:
  89   2            temp = BAUD_9K6;
  90   2            break;
  91   2          case UART_BAUD_19K2:
  92   2          default:
  93   2            temp = BAUD_19K2;
  94   2            break;
  95   2        }
  96   1        S0RELL = (uint8_t)temp;
  97   1        S0RELH = (uint8_t)(temp >> 8);
  98   1      
  99   1        TI0 = 0;
 100   1        ES0 = 1;                      // Enable UART0 interrupt
 101   1      }
 102          
 103          void hal_uart_putchar(uint8_t ch)
 104          {
 105   1        // Wait until there is space in the TX buffer:
 106   1        while(uart_tx_cnt > UART_NBUF)
 107   1          ;
 108   1        ES0 = 0;
 109   1        if (uart_tx_cnt == 0)
 110   1        {
 111   2          S0BUF = ch;                 // Write first char directly to the UART SFR
 112   2        }
 113   1        else
 114   1        {
 115   2          uart_tx[uart_tx_wp] = ch;
 116   2          uart_tx_wp = (uart_tx_wp + 1) % UART_NBUF;
 117   2        }
C51 COMPILER V9.00   HAL_UART                                                              10/26/2011 16:27:04 PAGE 3   

 118   1        uart_tx_cnt++;
 119   1        ES0 = 1;
 120   1      }
 121          
 122          
 123          uint8_t hal_uart_chars_available(void)
 124          {
 125   1        return uart_rx_cnt;
 126   1      }
 127          
 128          bool hal_uart_tx_complete()
 129          {
 130   1        if(uart_tx_cnt == 0)
 131   1        {
 132   2          return true;
 133   2        }
 134   1        else
 135   1        {
 136   2          return false;
 137   2        }
 138   1      }
 139          uint8_t hal_uart_getchar(void)
 140          {
 141   1        uint8_t ch;
 142   1      
 143   1        // Wait until a character is available:
 144   1      
 145   1        while(uart_rx_cnt == 0)
 146   1        {}
 147   1        ES0 = 0;
 148   1        ch = uart_rx[uart_rx_rp];
 149   1        uart_rx_rp = (uart_rx_rp + 1) % UART_NBUF;
 150   1        uart_rx_cnt--;
 151   1        ES0 = 1;
 152   1        return ch;
 153   1      }
 154          
 155          /**
 156           * @}
 157           */
*** WARNING C290 IN LINE 64 OF HAL_UART.C: missing return value


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    201    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      6    ----
   IDATA SIZE       =     16    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
